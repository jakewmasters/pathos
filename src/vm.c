/*
 * all code related to virtual memory (paging)
 */

/*
 * here's what we're working with (32-bit protected mode specific):
 * 
 * a page is 4K (4096) bytes. 
 * a page table entry, which refers to one page, is 4 bytes (32-bit)
 * a page table has 1024 page table entries
 * a page directory has 1024 page tables
 * ...and the page directory is ultimately what we pass to the MMU
 */

/*
 * options for virtualizing memory:
 *     - base & bounds: physical address = virtual address + base
 *         - where a virtual address is any reference generated by a running program, and the base is a value chosen by the OS to be stored in some register
 */

// 
void
clear_tlb()
{
    // __asm__ __volatile__("invlpg [0]");
}

// turns page_directory into a meaningful data structure
void
init_pde(void *page_directory)
{
    return;
}

void
enable_paging()
{
    void *page_directory;
    init_pde(page_directory); // initialize PDE

    // give cr3 address of PDE
    // __asm__ __volatile__("mov %1, %%eax; mov %%eax, %%cr3" : : "r" (page_directory) : "%eax");

    // enable paging by setting bit 31 of cr0 to 1
    // __asm__ __volatile__("mov %%cr0, %%ebx; or $0x80000000, %%ebx; mov %%ebx, %%cr0;" : : : "%ebx");

    return;
}