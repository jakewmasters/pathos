<meta charset="utf-8">

**Research Notes**

Overview
================

Author : Jake Masters

Started : 6/12/19

Last Updated : 6/24/19


Resources:
==========
Here are some amazing resources:
    - [Operating Systems Development](http://www.brokenthorn.com/Resources/OSDev0.html) (amazing)
    - [xv6](https://github.com/mit-pdos/xv6-public)
    - [biscuit](https://github.com/mit-pdos/biscuit)
    - [a decent bootloader tutorial](http://joebergeron.io/posts/post_two.html)
    - [an ok bootloader tutorial](https://blog.ghaiklor.com/2017/10/21/how-to-implement-your-own-hello-world-boot-loader/)

Notes
================

I'm going to write a bootloader. 

First, I'm going to look at xv6 and see how the group at PDOS did it. 

Boot process:
    - Upon powering on, most x86 machines kick off by soliciting the BIOS chip. 
    - The BIOS chip then transfers control to the designated **boot sector**. 
    - The **boot sector** is the first 512 bytes on the boot disk. 

Registers:
    - While simulating an Intel 8088, there are
        - 8 16bit general-purpose registers
            - %ax return register :)
        - 4 16bit segment registers
            - %cs for instruction fetches
            - %ds data read/write
            - %es "extra" segment? idk what this is
            - %ss stack read/write
        - processor sends 20 bits of address to memory, which come from segment register + gp register

how is it that a process can have a new program exec()ed onto it? the answer is the ELF format.

xv6
================

So xv6 consists of 102 files. 

Of these files, 8 are used directly as part of the boot process:
    - bootasm.S
        - memlayout.h
        - mmu.h
        - asm.h
    - bootmain.c
        - types.h
        - elf.h
        - x86.h

nvm the xv6 printout actually divides up all the files into 11 categories


NASM bootloader (6/13)
================

- The alleged "bootloader" is loaded into memory at 0x007c00
- The alleged "bootloader" should be 512 bytes in length, meaning the next available address should be 0x007e00
- So what if instead of starting our "stack" at 7CO, we started it at 0x7e00?

Let's map this out:
   bootloader...stack.......sp
---|------------|-----------|---
   0x7c00 (512) 0x7e00 (8k) 0x2000

- ds holds address where data region starts

BIOS interrupts:
================
- `0x10` has a bunch of video stuff
- `0x13` has a ton of disk stuff
- `0x16` has a bunch of keyboard stuff
- `0x1A` has a bunch of time stuff

A note about stack stuff:
=========================
- Caller-save:
    - Only needed if the calling function needs to reference its local data after callee function returns. 
    - Save registers before calling another function, restored after callee returns
    - This is the responsibility of the caller. 
- Callee-save:
    - Always do this!

Example... in boot.S:
    1. push bp to stack
    2. mov bp <- sp (base is set to top of stack (aka sp))
    3. push all general-purpose registers to stack
    4. { do stuff }
    5. restore (aka pop) all general-purpose registers
    6. mov sp <- bp (top of stack is now what it should be, is this really necessary though?)
    7. pop bp
    8. stack is now what it was before function ran

Also another cool thing I discovered: there's an x86 instruction called RDTSC that measures clock cycles. 

Commands:
=========
Assemble:
```
$ nasm -f bin src/boot.S -o boot.out
```
Run on bochs:
```
$ bochs -f bochsrc.txt
```
Run on qemu:
```
$ qemu-system-i386 -fda boot.out
```

Names:
======

- PathOS
    - Performant and Theoretically Helpful Operating System
- LogOS
    - Logically Organized Generative Operating System
- EthOS
    - Eternally Theologically Heretical Operating System
    - Existentially Threatened 


Processor Modes:
================
- Real Mode: 
    - 16-bit registers
    - 1 MB memory
    - **segment:offset** memory model
        - (segment*16 + offset) = exact memory address
    - stuff is unsafe

- Protected Mode: 
    - 32-bit registers
    - 4 GB RAM
    - a bit trickier, easy to triple fault

- Unreal Mode:
    - basically Real Mode with 4 GB memory
    - kind of a hack

- Virtual 8086 Mode
    - Protected Mode with a simulated Real Mode
    - allows use of BIOS interrupts (only available in Real Mode)


Birds-Eye View:
===============
- OSD Ch. 1-13 is all bootloader stuff
- Ch. 14+ is kernel level and beyond. 
    - I should probably see what the Kernel actually provides to know how mature my bootloader needs to be.
- Bootloader is, by nature, system dependent. 
- When I hit the kernel level, it does matter how ugly it gets, as long as it's contained with a nice bow on top. 
    - PathOS will have a nice interface, sure. But more than that, it will have the interior of a finely tuned piano. 
        - Give the piano the best chords you can, and then connect them to some nice keys and call it a day. 
        - Like who cares if a piano has shiny ivory keys if it sounds like trash. 
        - "Think of operating systems like pianos, sure they can have shiny ivory keys, but it doesn't matter if the chords are terrible and it sounds like trash." - Jake Masters

Multi-Stage Bootloaders:
========================
Back to the grind!

Stage 1 needs to do the following:
    - Starting out in 16-bit real mode
    - needs to set program origin (org) somewhere
        - `Boot1.asm` starts this at 0, not sure why.

Stage 2 needs to do the following:
    - Starting out in 16-bit real mode
    - program origin needs to be set
        - demo1 sets this to 0x00
        - demo3 has this at 0x500

The CMU lab write-up actually suggests the following memory map:
    - Avoid the first 4K of memory, it's reserved BIOS stuff.
    - boot0 should go in 0x7c00 through 0x7dff. That's 512 bytes. 

Here is my ideal memory map:
    - 0x0000 - 0x03ff IVT
    - 0x0400 - 0x04ff BIOS data
    - 0x0500 - 0x7bff 30K of free real estate
    - 0x7c00 - 0x7dff boot0
    - 0x7e00 - beyond who cares

So how does the loading part actually work?
    - The tutorial basically implements FAT12 to do this...
        - Ultimately, they're reading in root directory
        First, they compute the size of the entire root directory per RDE. 
            - (32 bytes * numRDEs) / bytesPerSector = RootDirectorySectors
    - There has to be a simpler way. 


GRUB Pivot:
===========
Alright so it turns out that bootloaders are really hard.  
I kinda just want to use GRUB for now, and once I have a debuggable kernel, come back to the bootloader. 

As of 6/24, I have finished the First Steps section of the Little OS Book. 
Time to work on "Getting to C". 


Minimum Viable System:
======================

What is the Minimum Viable System that can accomplish the following?
    - Bridges the gap between GRUB and some main kernel program `kmain.c`
    - Shows evidence that kmain ran (example, DEADBEEF shows up in bochsout.txt)

What's the next step?
    - Setting up a device driver to get display working
    - Implement printf for kmain.c
    - Get printf to print to stdout

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>